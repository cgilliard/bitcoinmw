use core::ptr::copy;
use core::slice::{from_raw_parts, from_raw_parts_mut};
use prelude::*;

pub const fn wrapping_mul(a: u64, b: u64) -> u64 {
	// Split a and b into high and low 32-bit parts
	let a_low = (a & 0xFFFFFFFF) as u32;
	let a_high = ((a >> 32) & 0xFFFFFFFF) as u32;
	let b_low = (b & 0xFFFFFFFF) as u32;
	let b_high = ((b >> 32) & 0xFFFFFFFF) as u32;

	// Compute partial products
	let low_low = (a_low as u64) * (b_low as u64);
	let low_high = (a_low as u64) * (b_high as u64);
	let high_low = (a_high as u64) * (b_low as u64);

	// Combine for lower 64 bits
	let low = low_low;
	let mid = low_high + high_low + (low_low >> 32);

	// Final result: lower 32 bits of low + lower 32 bits of mid
	(low & 0xFFFFFFFF) | ((mid & 0xFFFFFFFF) << 32)
}

pub const fn simple_hash(s: &str, line: u32) -> u64 {
	let mut hash = 0xCBF29CE484222325_u64; // FNV-1a 64-bit offset basis
	const PRIME: u64 = 0x100000001B3; // FNV-1a 64-bit prime

	// Hash the string bytes
	let bytes = s.as_bytes();
	let mut i = 0;
	while i < bytes.len() {
		hash = hash ^ (bytes[i] as u64);
		hash = wrapping_mul(hash, PRIME);
		i += 1;
	}

	// Hash the line number (as 4 bytes, little-endian)
	hash = hash ^ ((line & 0xFF) as u64);
	hash = wrapping_mul(hash, PRIME);
	hash = hash ^ (((line >> 8) & 0xFF) as u64);
	hash = wrapping_mul(hash, PRIME);
	hash = hash ^ (((line >> 16) & 0xFF) as u64);
	hash = wrapping_mul(hash, PRIME);
	hash = hash ^ (((line >> 24) & 0xFF) as u64);
	hash = wrapping_mul(hash, PRIME);

	hash
}

pub fn subslice<N>(n: &[N], off: usize, len: usize) -> Result<&[N]> {
	if off > n.len() || len.checked_add(off).map_or(true, |end| end > n.len()) {
		err!(OutOfBounds)
	} else {
		Ok(unsafe { from_raw_parts(n.as_ptr().add(off), len) })
	}
}

pub fn subslice_mut<N>(n: &mut [N], off: usize, len: usize) -> Result<&mut [N]> {
	if off > n.len() || len.checked_add(off).map_or(true, |end| end > n.len()) {
		err!(OutOfBounds)
	} else {
		Ok(unsafe { from_raw_parts_mut(n.as_mut_ptr().add(off), len) })
	}
}

pub fn slice_starts_with<N: PartialEq>(slice: &[N], prefix: &[N]) -> bool {
	let slice_len = slice.len();
	let prefix_len = prefix.len();
	if slice_len < prefix_len {
		false
	} else {
		for i in 0..prefix_len {
			if slice[i] != prefix[i] {
				return false;
			}
		}
		true
	}
}

pub fn slice_copy<T: Copy>(src: &[T], dst: &mut [T], len: usize) -> Result<()> {
	if dst.len() < len || src.len() < len {
		err!(OutOfBounds)
	} else {
		unsafe { copy(src.as_ptr(), dst.as_mut_ptr(), len) }
		Ok(())
	}
}

pub fn is_utf8_valid(bytes: &[u8]) -> Result<()> {
	let mut i = 0;
	while i < bytes.len() {
		let b = bytes[i];
		let len = if b <= 0x7F {
			// 1-byte (ASCII)
			1
		} else if (b & 0xE0) == 0xC0 {
			// 2-byte
			2
		} else if (b & 0xF0) == 0xE0 {
			// 3-byte
			3
		} else if (b & 0xF8) == 0xF0 {
			// 4-byte
			4
		} else {
			// Invalid leading byte
			return err!(Utf8Error);
		};

		// Check if there are enough bytes
		if i + len > bytes.len() {
			return err!(Utf8Error);
		}
		// Check continuation bytes
		for j in 1..len {
			if i + j < bytes.len() && (bytes[i + j] & 0xC0) != 0x80 {
				return err!(Utf8Error);
			}
		}

		i += len;
	}
	Ok(())
}

pub fn strcmp(a: &str, b: &str) -> i32 {
	let len = if a.len() > b.len() { b.len() } else { a.len() };
	let x = a.as_bytes();
	let y = b.as_bytes();

	for i in 0..len {
		if x[i] != y[i] {
			return if x[i] > y[i] { 1 } else { -1 };
		}
	}

	if a.len() < b.len() {
		1
	} else if a.len() > b.len() {
		-1
	} else {
		0
	}
}
